#include<iostream>
#include<string>
#include<vector>
#include<queue>
using namespace std;


class Solution {

public:
    int judge(string s1, string s2)        //求两个字符串之间是否能够转换
    {
        int distance = 0;
        for (int i = 0; i < 8; ++i)
        {
            if (s1[i] != s2[i])
            {
                ++distance;
            }
        }
        return distance == 1;               //距离为1，表示可以转换
    }
    int minMutation(string start, string end, vector<string>& bank) {
        if (start == end)                        //边界条件
        {
            return 0;
        }
        int len = bank.size();
        vector<bool> visited(len, false);       //标记是否已经访问
        int count = 0;                          //记录start经过几轮遍历找到end
        queue<string> q;                        //bfs辅助队列
        q.push(start);
        while (!q.empty())
        {
            ++count;                                //遍历轮数加一
            for (int i = 0; i < q.size(); ++i)       //一轮遍历
            {
                string now_start = q.front();       //队首节点出队
                q.pop();
                for (int j = 0; j < len; ++j)        //将此节点的临近节点全部入队
                {
                    if (!visited[j] && judge(now_start, bank[j]))     //若当前节点未访问过且可以访问
                    {
                        if (bank[j] == end)          //找到与end相同的节点
                        {
                            return count;           //返回遍历轮数
                        }
                        visited[j] = true;          //标记已访问
                        q.push(bank[j]);            //入队
                    }
                }
            }
        }
        return -1;                                  //未找到从start到达end的路径
    }
};


int main()
{
    //测试
    //string start = "AACCGGTT"; 
    //string end = "AACCGGTA"; 
    //vector<string> bank;
    //bank.push_back(string("AACCGGTA"));
    //Solution solution;
    //cout << solution.minMutation(start, end, bank) << endl;



    return 0;
}
